/**
 * Integration tests for PowerBI Service with other services
 */

const PowerBIService = require('../../src-v2/services/powerbiService');
const cacheService = require('../../src-v2/services/cacheService');
const errorService = require('../../src-v2/services/errorService');
const fs = require('fs');
const path = require('path');

describe('PowerBI Service Integration', () => {
    let powerbiService;
    let mockConfig;

    beforeEach(() => {
        // Clear any cached data
        cacheService.clearCache();

        // Use mock config to avoid real authentication
        mockConfig = {
            clientId: 'test-client-id',
            tenantId: 'test-tenant-id',
            clientSecret: 'test-client-secret',
            authorityUrl: 'https://login.microsoftonline.com/',
            scopeBase: 'https://analysis.windows.net/powerbi/api/.default',
            powerBIGroupId: 'test-group-id',
            powerBIReportId: 'test-report-id'
        };

        powerbiService = new PowerBIService(mockConfig);
    });

    describe('Configuration Integration', () => {
        it('should load configuration correctly', () => {
            expect(powerbiService.config).toEqual(mockConfig);
            expect(powerbiService.config.clientId).toBe('test-client-id');
            expect(powerbiService.config.powerBIGroupId).toBe('test-group-id');
        });

        it('should handle missing configuration gracefully', () => {
            const serviceWithoutConfig = new PowerBIService({});
            expect(serviceWithoutConfig.config).toEqual({});
        });
    });

    describe('Cache Service Integration', () => {
        it('should integrate with cache service for metadata', async () => {
            // First call should not use cache
            expect(cacheService.getCachedMetadata()).toBeNull();

            const metadata1 = await powerbiService.getDatasetMetadata('group-id', 'dataset-id');
            
            // Verify metadata was cached
            const cachedData = cacheService.getCachedMetadata();
            expect(cachedData).not.toBeNull();
            expect(cachedData.dataset.name).toBe('Store Sales');

            // Second call should use cache
            const metadata2 = await powerbiService.getDatasetMetadata('group-id', 'dataset-id');
            expect(metadata2).toEqual(metadata1);
        });

        it('should clear cache properly', async () => {
            // Get metadata to populate cache
            await powerbiService.getDatasetMetadata('group-id', 'dataset-id');
            expect(cacheService.getCachedMetadata()).not.toBeNull();

            // Clear cache
            cacheService.clearCache();
            expect(cacheService.getCachedMetadata()).toBeNull();
        });
    });

    describe('Service Architecture Integration', () => {
        it('should work with the v2 service architecture', () => {
            // Verify service can be instantiated in v2 architecture
            expect(powerbiService).toBeInstanceOf(PowerBIService);
            
            // Verify it has all required methods
            expect(typeof powerbiService.getAccessToken).toBe('function');
            expect(typeof powerbiService.getRequestHeader).toBe('function');
            expect(typeof powerbiService.getEmbedInfo).toBe('function');
            expect(typeof powerbiService.getDatasetMetadata).toBe('function');
            expect(typeof powerbiService.getSimplifiedMetadata).toBe('function');
            expect(typeof powerbiService.getNameOnlySchema).toBe('function');
        });

        it('should be compatible with error service patterns', async () => {
            // Test error handling follows errorService patterns
            try {
                // This should fail due to missing MSAL token
                await powerbiService.getAccessToken();
            } catch (error) {
                // Verify error is properly structured
                expect(error).toBeInstanceOf(Error);
                expect(error.message).toBeDefined();
            }
        });
    });

    describe('Metadata Processing Integration', () => {
        it('should process metadata consistently across formats', async () => {
            const completeMetadata = await powerbiService.getDatasetMetadata('group-id', 'dataset-id');
            const simplifiedMetadata = await powerbiService.getSimplifiedMetadata('group-id', 'dataset-id');
            const schemaMetadata = await powerbiService.getNameOnlySchema('group-id', 'dataset-id');

            // Verify all formats contain core information
            expect(completeMetadata.dataset.name).toBe('Store Sales');
            expect(simplifiedMetadata).toContain('Store Sales');
            expect(schemaMetadata).toContain('Sales.TotalSales');

            // Verify consistent table count across formats
            expect(completeMetadata.tables).toHaveLength(5);
            // Count tables in simplified format by counting table entries like "- TableName (type):"
            const tableMatches = simplifiedMetadata.match(/^- \w+ \(\w+\):/gm);
            expect(tableMatches).toHaveLength(5);
        });

        it('should maintain data consistency in different formats', async () => {
            const metadata = await powerbiService.getDatasetMetadata('group-id', 'dataset-id');
            const simplified = await powerbiService.getSimplifiedMetadata('group-id', 'dataset-id');
            const schema = await powerbiService.getNameOnlySchema('group-id', 'dataset-id');

            // Check that Sales table data is consistent
            const salesTable = metadata.tables.find(t => t.name === 'Sales');
            expect(salesTable).toBeDefined();
            expect(salesTable.columns).toHaveLength(2);

            expect(simplified).toContain('Sales (fact)');
            expect(simplified).toContain('TotalUnits (number)');
            expect(simplified).toContain('TotalSales (currency)');

            expect(schema).toContain('Sales.TotalUnits [number]');
            expect(schema).toContain('Sales.TotalSales [currency]');
        });
    });

    describe('Service Dependencies', () => {
        it('should work without external dependencies for hardcoded metadata', async () => {
            // This test verifies the service can function with hardcoded data
            const metadata = await powerbiService.getHardcodedMetadata();
            
            expect(metadata).toBeDefined();
            expect(metadata.dataset.name).toBe('Store Sales');
            expect(metadata.tables).toHaveLength(5);
            expect(metadata.measures).toHaveLength(2);
            expect(metadata.dimensions).toHaveLength(17);
        });

        it('should handle service instantiation with different configurations', () => {
            const configs = [
                mockConfig,
                { ...mockConfig, powerBIGroupId: 'different-group' },
                { ...mockConfig, powerBIReportId: 'different-report' },
                {}
            ];

            configs.forEach((config, index) => {
                const service = new PowerBIService(config);
                expect(service).toBeInstanceOf(PowerBIService);
                expect(service.config).toEqual(config);
            });
        });
    });

    describe('File System Integration', () => {
        it('should exist in correct service directory structure', () => {
            const servicePath = path.join(__dirname, '../../src-v2/services/powerbiService.js');
            expect(fs.existsSync(servicePath)).toBe(true);
            
            const content = fs.readFileSync(servicePath, 'utf8');
            expect(content).toContain('class PowerBIService');
            expect(content).toContain('module.exports = PowerBIService');
        });

        it('should have proper service imports', () => {
            const servicePath = path.join(__dirname, '../../src-v2/services/powerbiService.js');
            const content = fs.readFileSync(servicePath, 'utf8');
            
            expect(content).toContain("require('./configService')");
            expect(content).toContain("require('@azure/msal-node')");
            expect(content).toContain("require('node-fetch')");
            // cacheService has been deprecated and removed from imports
        });
    });
});